---
layout: post
title: Novinky v jazyku C# 11
date: 2022-11-15 18:00:00 +0100
tags: [C#, dotnet]
author: Mi≈ào Martiniak
comments: true
---
![Top 11 features of C# 11.png](/assets/images/Top_11_features_of_C_11.png)

## 1Ô∏è‚É£ Raw String Literals

Novinka, na ktor√∫ som osobne ƒçakal asi najviac. Nov√° verziu C# umo≈æ≈àuje zada≈• ƒæubovoƒæn√Ω text bez nutnosti escapovania. Najƒçastej≈°ie sa s t√Ωm stret√°vam keƒè potrebujem spravi≈• napr√≠klad inplace `JSON`.

Pou≈æi≈• je potrebn√© aspo≈à tri dvojit√© √∫vodzovky `""".."""`.

> Ak m√°te text obsahuj√∫ci tri dvojit√© √∫vodzovky, mus√≠te pou≈æi≈• ≈°tyri dvojit√© √∫vodzovky.

V kombin√°cii s string interpol√°ciou poƒçet `$` oznaƒçuje, koƒæko po sebe id√∫cich z√°tvoriek zaƒç√≠na a konƒç√≠ interpol√°ciu. V ni≈æ≈°ie uvedenom pr√≠klade chcem pou≈æi≈• interpol√°ciu v `JSON` stringu, ktor√Ω u≈æ obsahuje zlo≈æen√© z√°tvorky `{}`. To by bolo v rozpore s string interpolation, tak≈æe pou≈æijem dva `$$` na oznaƒçenie, ≈æe dvojit√© z√°tvorky `{{}}` zaƒç√≠naj√∫ a konƒçia interpol√°ciu.

```csharp
const string name = "Milan";
const string lastName = "Martiniak";

string json =
$$"""
{
    "Name": "{{name}}",
    "LastName": "{{lastName}}"
}
""";

Console.WriteLine(json);
```

Viac sa doƒç√≠tate priamo v dokument√°ci√≠ [Strings - C# Programming Guide](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/strings/#raw-string-literals).

## 2Ô∏è‚É£ Newlines in String Interpolation Expressions

So stringom pokraƒçujeme. ƒéal≈°ou u≈æitoƒçnou novinkou je mo≈ænos≈• vyu≈æ√≠va≈• riadkovanie v string interpol√°ci√≠. Doteraz to nebolo mo≈æn√©. Teraz to umo≈æn√≠ pou≈æi≈• ak√Ωkoƒævek val√≠dny C# k√≥d medzi `{}`, vr√°tane nov√Ωch riadkov. V√Ωrazne sa vylep≈°√≠ ƒçitatelnos≈• z√°pisov.

```csharp
const DayOfWeek day = DayOfWeek.Monday;

string dayInfo = $"Today is {day switch
{
    DayOfWeek.Saturday or DayOfWeek.Sunday => "weekend",
    _ => "working day"
}}.";

Console.WriteLine(dayInfo);
```

[Interpolated string expression newline - C# 11.0 draft specifications](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-11.0/new-line-in-interpolation)

## 3Ô∏è‚É£ UTF-8 String Literals

C# 11 prin√°≈°a UTF-8 string literals.

Zjednodu≈°√≠ to z√°pis konverzie UTF-8 znakov na ich bytov√∫ reprezent√°ciu. Konverzia sa vykon√°va v ƒçase kompil√°cie.

```csharp
// C# 10
//byte[] array = Encoding.UTF8.GetBytes("Hello UTF-8 String Literals");

// C# 11
ReadOnlySpan<byte> span = "Hello UTF-8 String Literals"u8;
byte[] array = "Hello UTF-8 String Literals"u8.ToArray();
```

## 4Ô∏è‚É£ Pattern match `Span<char>` on a constant string

Odteraz m√¥≈æete pou≈æi≈• pattern matching na overenie ƒçi `Span<char>` obsahuje konkr√©tny `string`.

```csharp
ReadOnlySpan<char> str = "World".AsSpan();

if (str is "World")
{
    Console.WriteLine("Hello world");
}
```

Dokument√°cia [Pattern match Span<<char>> - C# 11.0 draft specifications](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-11.0/pattern-match-span-of-char-on-string)

## 5Ô∏è‚É£ An Unsigned Right-shift Operator

C# 11 prin√°≈°a Right-shift Operator bez znamienka `>>>`.

Pos√∫va bity doprava bez replik√°cie bitu vy≈°≈°ieho r√°du pri ka≈ædom posune.

```csharp
int n = -32;
Console.WriteLine($"Before shift: bin = {Convert.ToString(n, 2),32}, dec = {n}");

int a = n >> 2;
Console.WriteLine($"After     >>: bin = {Convert.ToString(a, 2),32}, dec = {a}");

int b = n >>> 2;
Console.WriteLine($"After    >>>: bin = {Convert.ToString(b, 2),32}, dec = {b}");

// Output:
// Before shift: bin = 11111111111111111111111111100000, dec = -32
// After     >>: bin = 11111111111111111111111111111000, dec = -8
// After    >>>: bin =   111111111111111111111111111000, dec = 1073741816
```

[Bitwise and shift operators - C# reference](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/bitwise-and-shift-operators#unsigned-right-shift-operator-)

## 6Ô∏è‚É£ Static Abstract Members in Interfaces

Do rozhran√≠ m√¥≈æete odteraz prida≈• statick√© abstraktn√© ƒçleny a definova≈• rozhrania, ktor√© zah≈ï≈àaj√∫ pre≈•a≈æen√© oper√°tory, in√© statick√© ƒçleny a statick√© vlastnosti.

```csharp
void NumberOfLegs<T>(T animal) where T: IAnimal {
    Console.WriteLine(T.NumberOfLegs);
}

NumberOfLegs(new Dog());
NumberOfLegs(new Snake());

public record Dog : IAnimal
{
    public static int NumberOfLegs => 4;
}

public record Snake : IAnimal
{
    public static int NumberOfLegs => 0;
}

public interface IAnimal
{
    static abstract int NumberOfLegs { get; }
}
```

Ok, viem toto nie je dobr√Ω pr√≠klad üôÇ, ale neodpustil som si. Re√°lnej≈°ie pou≈æitie bude sk√¥r na pre≈•a≈æovanie oper√°torov. Napr√≠klad `static abstract T operator +(T a, T b);` a ka≈æd√Ω typ si potom definuje svoje spr√°vanie.

Viac info [Explore static virtual members in interfaces](https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/tutorials/static-virtual-interface-members)

## 7Ô∏è‚É£ Extended `nameof` Scope

N√°zov parametra met√≥dy m√¥≈æete zada≈• v atrib√∫te pri deklar√°cii met√≥dy alebo parametra.

Toto je mo≈æn√© vyu≈æi≈• napr√≠kladpri prid√°van√≠ atrib√∫tov na anal√Ωzu k√≥du, alebo automatickom generovan√≠ pomocou [C# Source Generators](https://blog.burgyn.online/2022/10/10/csharp-source-generator).

```csharp
public class MyAttribute : Attribute
{
    private readonly string _paramName;
    public MyAttribute(string paramName)
    {
        _paramName = paramName;
    }
}
public class MyClass
{
    [My(nameof(param))]
    public void Method(int param, [My(nameof(param))] int anotherParam)
    { }
}
```

Detail n√°vrhu [Extended nameof parameter scope - C# 11.0 draft specifications](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-11.0/extended-nameof-scope)

## 8Ô∏è‚É£ Required Members

C# 11 prin√°≈°a nov√Ω `required` modifik√°tor pre vlastnosti na vyn√∫tenie zadania pri inicializ√°ci√≠. Ak inicializujete objekt s ch√Ωbaj√∫cou po≈æadovanou vlastnos≈•ou, zobraz√≠ sa chyba kompil√°cie.

```csharp
public class Person
{
    public Guid Id { get; set; } = Guid.NewGuid();
    public required string Name { get; set; }
    public required string LastName { get; set; }
}

// Initializations with required properties - valid
var p1 = new Person { Name = "Milan", LastName = "Martiniak" };
Person p2 = new("Milan", "Martiniak");

// Initializations with missing required properties - compilation error
var p3 = new Person { Name = "Milan" };
Person p4 = new();
```

Ak m√°te niekoƒæko parametrick√Ωch kon≈°truktorov, mali by ste prida≈• atrib√∫t `SetsRequiredMembers` na kon≈°truktor, ktor√Ω inicializuje v≈°etky po≈æadovan√© vlastnosti.

```csharp
public class Person
{
    public Person() { }

    [SetsRequiredMembers]
    public Person(string name, string lastName)
    {
        Name = name;
        LastName = lastName;
    }

    public Guid Id { get; set; } = Guid.NewGuid();
    public required string Name { get; set; }
    public required string LastName { get; set; }
}
```

Dokument√°cia [required modifier - C# Reference](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/required)

## 9Ô∏è‚É£ Auto-default Structs

Ak ste pred C# 11 deklarovali ≈°trukt√∫ru s kon≈°truktorom, museli ste priradi≈• ka≈æd√∫ vlastnos≈•. V opaƒçnom pr√≠pade ste dostali kompilaƒçn√∫ chybu.

`[CS0171] Field 'PersonStruct.Age' must be fully assigned before control is returned to the caller.`

V aktu√°lnej verzii kompil√°tor nastav√≠ default hodnoty pre vynechan√© vlastnosti.

```csharp
struct PersonStruct
{
    public PersonStruct(string name)
    {
        Name = name;
    }

    public string Name { get; set; }
    public int Age { get; set; }
}
```

Viac v ≈°pecifik√°ci√≠ [Structure types - C# reference](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/struct#struct-initialization-and-default-values)

## üîü List Patterns

C# 11 roz≈°iruje aktu√°lny pattern matching o mo≈ænos≈• zis≈•ovania zhody sekvencie elementov v poliach a listoch.

```csharp
var numbers = new[] { 1, 2, 3, 4 };

// List and constant patterns
Console.WriteLine(numbers is [1, 2, 3, 4]); // True
Console.WriteLine(numbers is [1, 2, 4]);    // False

// List and discard patterns
Console.WriteLine(numbers is [_, 2, _, 4]); // True
Console.WriteLine(numbers is [.., 3, _]);   // True

// List and logical patterns
Console.WriteLine(numbers is [_, >= 2, _, _]); // True
```

Dokument√°cia: [Patterns - C# reference](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/patterns#list-patterns)

## 1Ô∏è‚É£1Ô∏è‚É£ Generic Attributes

Pokiaƒæ ste potrebovali v star≈°ej verzii C# do atrib√∫tu posla≈• typ, tak ste to museli spravi≈• pomocou kon≈°truktora a n√°sledne vyu≈æi≈• `typeof` expression.

V C# 11 u≈æ m√¥≈æete pekne vytvori≈• generick√Ω atrib√∫t.

```csharp
// Before C# 11:
public class TypeAttribute : Attribute
{
    public TypeAttribute(Type type) => ParamType = type;

    public Type ParamType { get; }
}

public class GenericAttribute<T> : Attribute
{
}

// After C#
[Generic<int>]
public class MyType
{
    [Generic<int>()]
    public void Method() {}
}
```

[Generic Attributes](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-11.0/generic-attributes)

## Zdroje

[Reposit√°r s pr√≠kladmi](https://github.com/Burgyn/Sample.CSharp11)